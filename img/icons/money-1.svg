}
    
    /**
     * Create a new route category. Each route must belong to a category.
     *
     * @param nameResId Resource ID of the name of the new category
     * @param isGroupable true if routes in this category may be grouped with one another
     * @return the new RouteCategory
     */
    public RouteCategory createRouteCategory(int nameResId, boolean isGroupable) {
        return new RouteCategory(nameResId, ROUTE_TYPE_USER, isGroupable);
    }

    static void updateRoute(final RouteInfo info) {
        dispatchRouteChanged(info);
    }

    static void dispatchRouteSelected(int type, RouteInfo info) {
        for (CallbackInfo cbi : sStatic.mCallbacks) {
            if ((cbi.type & type) != 0) {
                cbi.cb.onRouteSelected(cbi.router, type, info);
            }
        }
    }

    static void dispatchRouteUnselected(int type, RouteInfo info) {
        for (CallbackInfo cbi : sStatic.mCallbacks) {
            if ((cbi.type & type) != 0) {
                cbi.cb.onRouteUnselected(cbi.router, type, info);
            }
        }
    }

    static void dispatchRouteChanged(RouteInfo info) {
        for (CallbackInfo cbi : sStatic.mCallbacks) {
            if ((cbi.type & info.mSupportedTypes) != 0) {
                cbi.cb.onRouteChanged(cbi.router, info);
            }
        }
    }

    static void dispatchRouteAdded(RouteInfo info) {
        for (CallbackInfo cbi : sStatic.mCallbacks) {
            if ((cbi.type & info.mSupportedTypes) != 0) {
                cbi.cb.onRouteAdded(cbi.router, info);
            }
        }
    }

    static void dispatchRouteRemoved(RouteInfo info) {
        for (CallbackInfo cbi : sStatic.mCallbacks) {
            if ((cbi.type & info.mSupportedTypes) != 0) {
                cbi.cb.onRouteRemoved(cbi.router, info);
            }
        }
    }

    static void dispatchRouteGrouped(RouteInfo info, RouteGroup group, int index) {
        for (CallbackInfo cbi : sStatic.mCallbacks) {
            if ((cbi.type & group.mSupportedTypes) != 0) {
                cbi.cb.onRouteGrouped(cbi.router, info, group, index);
            }
        }
    }

    static void dispatchRouteUngrouped(RouteInfo info, RouteGroup group) {
        for (CallbackInfo cbi : sStatic.mCallbacks) {
            if ((cbi.type & group.mSupportedTypes) != 0) {
                cbi.cb.onRouteUngrouped(cbi.router, info, group);
            }
        }
    }

    static void dispatchRouteVolumeChanged(RouteInfo info) {
        for (CallbackInfo cbi : sStatic.mCallbacks) {
            if ((cbi.type & info.mSupportedTypes) != 0) {
                cbi.cb.onRouteVolumeChanged(cbi.router, info);
            }
        }
    }

    static void dispatchRoutePresentationDisplayChanged(RouteInfo info) {
        for (CallbackInfo cbi : sStatic.mCallbacks) {
            if ((cbi.type & info.mSupportedTypes) != 0) {
                cbi.cb.onRoutePresentationDisplayChanged(cbi.router, info);
            }
        }
    }

    static void systemVolumeChanged(int newValue) {
        final RouteInfo selectedRoute = sStatic.mSelectedRoute;
        if (selectedRoute == null) return;

        if (selectedRoute == sStatic.mBluetoothA2dpRoute ||
                selectedRoute == sStatic.mDefaultAudioVideo) {
            dispatchRouteVolumeChanged(selectedRoute);
        } else if (sStatic.mBluetoothA2dpRoute != null) {
            try {
                dispatchRouteVolumeChanged(sStatic.mAudioService.isBluetoothA2dpOn() ?
                        sStatic.mBluetoothA2dpRoute : sStatic.mDefaultAudioVideo);
            } catch (RemoteException e) {
                Log.e(TAG, "Error checking Bluetooth A2DP state to report volume change", e);
            }
        } else {
            dispatchRouteVolumeChanged(sStatic.mDefaultAudioVideo);
        }
    }

    static void updateWifiDisplayStatus(WifiDisplayStatus newStatus) {
        final WifiDisplayStatus oldStatus = sStatic.mLastKnownWifiDisplayStatus;

        // TODO Naive implementation. Make this smarter later.
        boolean wantScan = false;
        boolean blockScan = false;
        WifiDisplay[] oldDisplays = oldStatus != null ?
                oldStatus.getRememberedDisplays() : new WifiDisplay[0];
        WifiDisplay[] newDisplays = newStatus.getRememberedDisplays();
        WifiDisplay[] availableDisplays = newStatus.getAvailableDisplays();
        WifiDisplay activeDisplay = newStatus.getActiveDisplay();

        for (int i = 0; i < newDisplays.length; i++) {
            final WifiDisplay d = newDisplays[i];
            final WifiDisplay oldRemembered = findMatchingDisplay(d, oldDisplays);
            if (oldRemembered == null) {
                addRouteStatic(makeWifiDisplayRoute(d,
                        findMatchingDisplay(d, availableDisplays) != null));
                wantScan = true;
            } else {
                final boolean available = findMatchingDisplay(d, availableDisplays) != null;
                final RouteInfo route = findWifiDisplayRoute(d);
                updateWifiDisplayRoute(route, d, available, newStatus);
            }
            if (d.equals(activeDisplay)) {
                final RouteInfo activeRoute = findWifiDisplayRoute(d);
                if (activeRoute != null) {
                    selectRouteStatic(activeRoute.getSupportedTypes(), activeRoute);

                    // Don't scan if we're already connected to a wifi display,
                    // the scanning process can cause a hiccup with some configurations.
                    blockScan = true;
                }
            }
        }
        for (int i = 0; i < oldDisplays.length; i++) {
            final WifiDisplay d = oldDisplays[i];
            final WifiDisplay newDisplay = findMatchingDisplay(d, newDisplays);
            if (newDisplay == null) {
                removeRoute(findWifiDisplayRoute(d));
            }
        }

        if (wantScan && !blockScan) {
            sStatic.mDisplayService.scanWifiDisplays();
        }

        sStatic.mLastKnownWifiDisplayStatus = newStatus;
    }

    static RouteInfo makeWifiDisplayRoute(WifiDisplay display, boolean available) {
        final RouteInfo newRoute = new RouteInfo(sStatic.mSystemCategory);
        newRoute.mDeviceAddress = display.getDeviceAddress();
        newRoute.mSupportedTypes = ROUTE_TYPE_LIVE_AUDIO | ROUTE_TYPE_LIVE_VIDEO;
        newRoute.mVolumeHandling = RouteInfo.PLAYBACK_VOLUME_FIXED;
        newRoute.mPlaybackType = RouteInfo.PLAYBACK_TYPE_REMOTE;

        newRoute.setStatusCode(available ?
                RouteInfo.STATUS_AVAILABLE : RouteInfo.STATUS_CONNECTING);
        newRoute.mEnabled = available;

        newRoute.mName = display.getFriendlyDisplayName();

        newRoute.mPresentationDisplay = choosePresentationDisplayForRoute(newRoute,
                sStatic.getAllPresentationDisplays());
        return newRoute;
    }

    private static void updateWifiDisplayRoute(RouteInfo route, WifiDisplay display,
            boolean available, WifiDisplayStatus wifiDisplayStatus) {
        final boolean isScanning =
                wifiDisplayStatus.getScanState() == WifiDisplayStatus.SCAN_STATE_SCANNING;

        boolean changed = false;
        int newStatus = RouteInfo.STATUS_NONE;

        if (available) {
            newStatus = isScanning ? RouteInfo.STATUS_SCANNING : RouteInfo.STATUS_AVAILABLE;
        } else {
            newStatus = RouteInfo.STATUS_NOT_AVAILABLE;
        }

        if (display.equals(wifiDisplayStatus.getActiveDisplay())) {
            final int activeState = wifiDisplayStatus.getActiveDisplayState();
            switch (activeState) {
                case WifiDisplayStatus.DISPLAY_STATE_CONNECTED:
                    newStatus = RouteInfo.STATUS_NONE;
                    break;
                case WifiDisplayStatus.DISPLA