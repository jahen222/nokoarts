        if (!route.getName().equals(newName)) {
            route.mName = newName;
            changed = true;
        }

        changed |= route.mEnabled != available;
        route.mEnabled = available;

        changed |= route.setStatusCode(newStatus);

        if (changed) {
            dispatchRouteChanged(route);
        }

        if (!available && route == sStatic.mSelectedRoute) {
            // Oops, no longer available. Reselect the default.
            final RouteInfo defaultRoute = sStatic.mDefaultAudioVideo;
            selectRouteStatic(defaultRoute.getSupportedTypes(), defaultRoute);
        }
    }

    private static WifiDisplay findMatchingDisplay(WifiDisplay d, WifiDisplay[] displays) {
        for (int i = 0; i < displays.length; i++) {
            final WifiDisplay other = displays[i];
            if (d.getDeviceAddress().equals(other.getDeviceAddress())) {
                return other;
            }
        }
        return null;
    }

    private static RouteInfo findWifiDisplayRoute(WifiDisplay d) {
        final int count = sStatic.mRoutes.size();
        for (int i = 0; i < count; i++) {
            final RouteInfo info = sStatic.mRoutes.get(i);
            if (d.getDeviceAddress().equals(info.mDeviceAddress)) {
                return info;
            }
        }
        return null;
    }

    private static Display choosePresentationDisplayForRoute(RouteInfo route, Display[] displays) {
        if ((route.mSupportedTypes & ROUTE_TYPE_LIVE_VIDEO) != 0) {
            if (route.mDeviceAddress != null) {
                // Find the indicated Wifi display by its address.
                for (Display display : displays) {
                    if (display.getType() == Display.TYPE_WIFI
                            && route.mDeviceAddress.equals(display.getAddress())) {
                        return display;
                    }
                }
                return null;
            }

            if (route == sStatic.mDefaultAudioVideo && displays.length > 0) {
                // Choose the first presentation display from the list.
                return displays[0];
            }
        }
        return null;
    }

    /**
     * Information about a media route.
     */
    public static class RouteInfo {
        CharSequence mName;
        int mNameResId;
        private CharSequence mStatus;
        int mSupportedTypes;
        RouteGroup mGroup;
        final RouteCategory mCategory;
        Drawable mIcon;
        // playback information
        int mPlaybackType = PLAYBACK_TYPE_LOCAL;
        int mVolumeMax = RemoteControlClient.DEFAULT_PLAYBACK_VOLUME;
        int mVolume = RemoteControlClient.DEFAULT_PLAYBACK_VOLUME;
        int mVolumeHandling = RemoteControlClient.DEFAULT_PLAYBACK_VOLUME_HANDLING;
        int mPlaybackStream = AudioManager.STREAM_MUSIC;
        VolumeCallbackInfo mVcb;
        Display mPresentationDisplay;

        String mDeviceAddress;
        boolean mEnabled = true;

        // A predetermined connection status that can override mStatus
        private int mStatusCode;

        /** @hide */ public static final int STATUS_NONE = 0;
        /** @hide */ public static final int STATUS_SCANNING = 1;
        /** @hide */ public static final int STATUS_CONNECTING = 2;
        /** @hide */ public static final int STATUS_AVAILABLE = 3;
        /** @hide */